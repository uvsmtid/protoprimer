---
feature_topic: FT_14_52_73_23
topic_title: primer phase
topic_status: TODO
---

## `protoprimer` execution phases

There are few primer runtimes:

*   `proto` = independent (stand-alone)

    This phase runs [FT_90_65_67_62.proto_code.md][FT_90_65_67_62.proto_code.md].

    It is designed to run outside of `venv` (or inside `venv` without `protoprimer` package installed).

*   `venv`

    This phase runs via `protoprimer.primer_kernel` module directly.

    It relies on initialized `venv`.

*   `neo`

    This phase is client-specific (custom) setup that may install and rely on any other packages in `venv`.

    *   `protoprimer` package supports transition to that phase, but does not implement such states (out of its scope).

    *   `neoprimer` package implements some states to run in `neo` phase (to be used as is or customized by the client).

## Why do we need these phases?

The proto phase (potentially) has no access to any packages (accessed via `venv`) -
it runs only a stand-alone [FT_90_65_67_62.proto_code.md][FT_90_65_67_62.proto_code.md]
(limited only to the states defined there).

Any client-specific states only become accessible in `venv` phase which starts
another [FT_72_45_12_06.python_executable.md][FT_72_45_12_06.python_executable.md].

## How does transition from `proto` to `venv` phases work?

It relies on the implementation of [FT_75_87_82_46.entry_script.md][FT_75_87_82_46.entry_script.md]
to detect `ImportError` and conditionally run different `main` functions:
*   either from client code
*   or from `proto_code`

```python
#!/usr/bin/env python

if __name__ == "__main__":

    try:
        from client_code import custom_main as selected_main
    except ImportError:
        from proto_kernel import main as selected_main

    selected_main()
```

For this to work, both `main` functions have to implement similar behavior.
For example, their command line interface (CLI) should handle the same set of args.
To achieve that, client code effectively runs the same code:

1.  either `proto_code` in proto phase (which is a copy of the 2nd)
2.  or `protoprimer.primer_kernel` in `venv` phase

However, even if `protoprimer` code remains the same,
the purpose of the 2nd phase is to customize it in client code and run any modules available in `venv`.

From the user point of view, the same script will appear to have extra states depending on whether `venv` is initialized.

## How to specify target state available only in `venv` phase?

TODO: Implement this (and update):

`proto_code` is supposed to recognize two args for the two target states:
*   `state_name_proto` target is recognized in both `phase_proto` and `phase_venv`.
*   `state_name_venv` target is recognized only in `phase_venv`.

---

[FT_90_65_67_62.proto_code.md]: FT_90_65_67_62.proto_code.md
[FT_72_45_12_06.python_executable.md]: FT_72_45_12_06.python_executable.md
[FT_75_87_82_46.entry_script.md]: FT_75_87_82_46.entry_script.md
