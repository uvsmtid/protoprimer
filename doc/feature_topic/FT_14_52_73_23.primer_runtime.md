---
feature_topic: FT_14_52_73_23
topic_title: primer runtime
topic_status: TODO
---

## `protoprimer` execution runtimes

TODO: It seems like this concept of runtimes is redundant:
    -   [FT_72_45_12_06.python_executable.md][FT_72_45_12_06.python_executable.md] cover python exec transition
    -   [FT_89_41_35_82.conf_leap.md][FT_89_41_35_82.conf_leap.md] covers configuration discovery
    What does runtime explain? When does one runtime changes to another?

There are a few primer runtimes:

*   `proto` = independent (stand-alone)

    This runtime runs [FT_90_65_67_62.proto_code.md][FT_90_65_67_62.proto_code.md].

    It is designed to start outside of `venv` (or inside arbitrary `venv` without `protoprimer` package installed).

    Subsequently, it switches to initialized `venv` with installed `protoprimer` and
    runs `protoprimer.primer_kernel` module directly before switching to `neo` runtime eventually.

*   `neo`

    This runtime is client-specific (custom) setup that may install any other packages in `venv`.

    *   `protoprimer` package only implements transition into that runtime (`proto` -> `neo`).

         But `protoprimer` does not implement `neo` states (they are out of its scope).

    *   `neoprimer` package implements states to be run in `neo` runtime.

        These states can be run as is or customized by the client code.

## Why do we need these runtimes?

The `proto` runtime (potentially) has no access to any packages (accessed via `venv`) when it starts -
it runs a stand-alone [FT_90_65_67_62.proto_code.md][FT_90_65_67_62.proto_code.md]
(limited only to the states defined there).

Any client-specific states only become accessible in `neo` runtime which starts
another [FT_72_45_12_06.python_executable.md][FT_72_45_12_06.python_executable.md].

## How does transition from `proto` to `neo` runtimes work?

It relies on the implementation of [FT_75_87_82_46.entry_script.md][FT_75_87_82_46.entry_script.md]
to call `run_main` function which detects `ImportError` and conditionally run different `main` functions:
*   either from client code
*   or from `proto_code`

```python
try:
    # `PrimerRuntime.runtime_neo`:
    # ...
    selected_main = custom_main
except ImportError:
    # `PrimerRuntime.runtime_proto`:
    selected_main = main

selected_main()
```

Depending on whether it is `venv` or not:
*   Outside `venv` with necessary packages, it executes `selected_main` from `proto_kernel`.
*   Inside `venv` with necessary packages, it executes `selected_main` from `client_code`.

It also requires [FT_62_88_55_10.CLI_compatibility.md][FT_62_88_55_10.CLI_compatibility.md].

## How to specify target state available only in `neo` runtime?

See [FT_74_10_40_33.DAG_extension.md][FT_74_10_40_33.DAG_extension.md].

---

[FT_90_65_67_62.proto_code.md]: FT_90_65_67_62.proto_code.md
[FT_72_45_12_06.python_executable.md]: FT_72_45_12_06.python_executable.md
[FT_75_87_82_46.entry_script.md]: FT_75_87_82_46.entry_script.md
[FT_74_10_40_33.DAG_extension.md]: FT_74_10_40_33.DAG_extension.md
[FT_62_88_55_10.CLI_compatibility.md]: FT_62_88_55_10.CLI_compatibility.md
[FT_89_41_35_82.conf_leap.md]: FT_89_41_35_82.conf_leap.md
